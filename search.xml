<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Git管理SVN项目]]></title>
    <url>%2F2017%2F12%2F02%2F%E4%BD%BF%E7%94%A8Git%E7%AE%A1%E7%90%86SVN%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Git 中有一个神奇的功能，他可以让你用 Git 来管理 SVN。两个之间互不冲突，对于喜欢使用 Git 的同志，这是一个非常不错的选择。自从有了它妈妈再也不用担心 SVN 不好用了。 缘起公司的项目使用的是svn来管理的，而我早就转向git了，但是公司使用的是svn我也没办法。最开始在 macOS 上使用命令行（只有我一个人用），但是好久没用了，命令也基本都忘了。找了半天也没有满意的客户端软件，直到别人推荐Cornerstone，用了一段时间还不错。但是后面用着还是发现了许多问题，用着不舒服。也就是这个不舒服，让我想换回命令行使用，于是我在Dash中输入svn却搜索出了git svn这个东西。最开始我以为这是一个把svn项目转为git的工具，于是看了一下说明，如获至宝。原来这货是用git来管理svn的工具，并且可以向svn提交代码，这比转换的功能牛逼多了。真是好激动！！！ 主要功能把svn项目clone到本地首先要有svn的仓库，没有的话就搭建一个（不然怎么玩）。 先把仓库clone到本地1git svn clone svn://127.0.0.1 test -T trunk -b branches -t tags 如果你在Linux下面输入这句话，会报以下错误，在macOS上面没碰到。1234567$ git svngit: 'svn' is not a git command. See 'git --help'.The most similar commands are fsck mv show 一开始我以为我安装的版本太旧了不支持git svn，于是升级到最新。升级之后我再次尝试，得到的结果还是一样，历史总是惊人的相似。开始查资料，这次比较幸运，一查就中。解决方法就是安装git svn。1sudo apt install git-svn 再次执行clone输入账号和密码就可以正常使用了，svn上的东西就会被clone到本地的test目录下。这时候就可以把git当成svn客户端来使用。其实git svn clone是git svn init和git svn fetch连个命令的组合。-T trunk -b branches -t tags其中-T、-b、-t对应svn中的主干、分支、和标签名称。这些通常是标准的（没有修改过），由于使用很频繁，这整句可以使用-s来代替。 把文件加入版本控制在clone了svn的项目之后，就可以使用git命令来管理svn项目。我们先创建一个新的文件并把它加入到版本控制中。12touch README.mdgit add README.md 提交代码git是一个分布式版本控制系统，这和svn是不一样的。svn在没有网络的情况下是没法提交代码的，而使用了git svn后就可以享受到分布式版本控制的好处，可以在本地进行提交变更。向本地提交变更和git原来的使用方式一样，使用git commit就行了。1git commit -m "add README.md" 向svn推送更新工作中可能会有许多小伙伴一起维护一个项目，使用git我们可以先把变更提交到本地，然后把己修改的代码推送到svn服务器，这时候就要用到git svn dcommit来向svn提交代码。1git svn dcommit 这里需要注意一点，git在往服务器推送之前，需要更新为最新的内容，不然是无法合并的。而svn只需要有冲突的时候才需要这样做，获取最新的内容见下一小节。当有人更新了一个A的文件，这时候你更新了B文件，这时候使用git svn dcommit是可以正常工作的。假如在git下使用commit向本地提交了多次，这时候使用git svn dcommit会把向本地提交的多次更新，依次向svn服务器推送。也就说你使用git commit向本地提交了多次更新，在使用git svn dcommit之后svn里的 log 就会有多次更新。 从svn拉取更新除了自己向svn服务器提交代码，别人也会向服务器提交代码，我们需要把别人向服务器提交的代码同步下来，以获取最新的代码。从服务器拉取最新的更新使用git svn rebase,它会拉取服务器上最新的改变，在此基础上rebase(衍合)你的修改。1git svn rebase git svn rebase虽好用，但是还不能适应所有场景。比如：你本地更改了某个文件，没有提交这个更新，此时你想从svn上更新，这时候使用git svn rebase是不行的。因为git svn rebase需要保证工作目录是干净的,你改动了就已经不干净了。这时候就需要用git svn fetch来拉取svn上的内容到本地，但是它不会merge到当前分支，通常需要我们手动去合并。12git svn fetchgit merge git-svn 其它一些功能ignore项目中有些文件我们不想加入到版本控制系统中，比如：在 macOS 下面的文件系统、项目中编译生成的文件、IDE 的配置。这些每个人的都不一样，纳入到版本控制中会污染整个项目，别人更新了你的配置还会对别人造成不必要的麻烦。所以这些文件是不应该被加入到版本控制中的，如果我们手动去管理，这会变得非常麻烦，管理这些需要花太多精力，一个好的工程师应不应该话太多时间在这上面。幸好svn和git都提供了ignore来把一些不需要加入版本控制的文件给管理起来。在使用中git的ignore会比svn的好用，git只需要在.gitignore中写一些规则就可以了，svn就麻烦了许多。使用git管理svn的ignore也是很简单的。1git svn create-ignore 它会自动创建.gitignore文件，并把svn中的ignore拷贝到git中。除了上面的方法，还有下面这种方法也可以用来管理ignore1git svn show-ignore &gt; .git/info/exclude log在git中我们查看 log，可以使用git log来查看。对于熟悉svn的同学可能习惯了svn的显示风格，可以使用git svn log显示svn风格的 log。在svn中查看 log是需要连上网络不能离线的，但是用git svn log是可以在没有网络的情况下查看 log的，这一点似乎增强了svn的功能。 svn 服务器信息svn提供了svn info来查看服务器信息，当然也可以使用git svn info来查看。 参考Git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue使用总结]]></title>
    <url>%2F2017%2F11%2F15%2FVue%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文基于 Vue 2.0,聊一聊 Vue 的使用。 简单介绍（官网介绍） Vue.js (读音 /vjuː/，类似于 view) 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 我个人觉得有基础的人学习 Vue 上手是比较快的，使用也是简单，并且还有完整的生态并且社区活跃，相信学习 Vue 会是一件有价值的事。 在项目中集成 Vue简单的，写代码的方式简单点。我们从简单的开始，Vue 是一个 js 库，想要在项目中使用，需要在项目中引用 Vue，Vue 的引用和引用 JavaScript 库没有区别。1&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; 把 Vue 集成进项目后，实例化一个 Vue 对象来对接原生开发。Vue 对象是我们介入原生开的入口，通过这个入口就能使用 Vue 来开发。123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello,Vue!' &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 在script标签里，我们创建了一个 Vue 对象。在 Vue 对象中有el字段,它代表我们创建的 Vue 对象要在哪个元素上进行操作，以后 Vue 所有的操作都会在该元素下，Vue 中的所有元素都是该元素的子元素。el可以通过 CSS 选择器来指定具体的元素。另外一个重要的字段就是data，Vue 是一个 MVVM 框架，没有数据和咸鱼有什么区别。在data中的数据就可以在 html 中访问，最简单就是使用{ { } }来访问。{ { } }是模板语法，会简单的显示文本内容，当data中的数据发生变化时，{ { } }中的会自动更新。 模板指令在了解了怎么在项目中引入 Vue 之后，就来了解一下 Vue 的使用。 文本渲染 普通文本渲染给什么就显示什么。不会进行编译，原样输出。就算你给了一段 html 也只是原样输出而已。 123&lt;div&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 除了使用{ { } }来渲染文本，还可以使用v-text来更新内容。 1&lt;span v-text="message"&gt;&lt;/span&gt; 使用v-text和使用{ { } }都是更新元素的textContent,不过要更新局部或者部分还是要使用{ { } }。 html 渲染如果我们只是简单的想要渲染文本，使用{ { } }就够了。但是我们有可能会需要渲染 html，这时候就需要使用v-html来渲染包含 html 的内容。与v-text不通过的是v-html更新的是元素的innerHTML，v-html会按照普通的 html 来进行插入，不会进行编译。12&lt;div v-html="&lt;h1&gt;我是 h1 标签"&gt;&lt;/div&gt; 条件渲染Vue 提供了v-if来控制标签的渲染，v-if会根据表达式的值来决定是否渲染。当表达式为不为true时可以使用v-else来渲染其他内容，v-else不需要表达式，但是v-else前一兄弟必须要有v-if或者v-else-if。v-else-if和v-if一样也是用来判断条件的。123456789101112&lt;div id="app"&gt; &lt;p v-if="isShow"&gt;显示&lt;/p&gt; &lt;p v-else&gt;不显示&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isShow: true &#125; &#125;)&lt;/script&gt; 循环循环在编程中是必不可少的，Vue 怎么能缺席呢。 Vue 提供v-for指令来表示要循环。 123456789101112131415&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="item in items"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; items: ['Java','C/C++','JavaScript','Python','PHP','SQL'] &#125; &#125;)&lt;/script&gt; v-for还提供了索引功能，所以上面的代码还可以修改成： 123&lt;li v-for="(item,index) in items"&gt; &#123;&#123;index + ":" + item&#125;&#125;&lt;/li&gt; v-for不仅可以遍历数组，还可以遍历对象的每个属性 123456789101112131415161718&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="(value,key) in user"&gt; &#123;&#123;key + ":" + value&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; user: &#123; name: 'Vue', version: '2.0' &#125; &#125; &#125;)&lt;/script&gt; 属性绑定在 Vue 中，属性是不能使用{ { } }进行绑定的。所以 Vue 提供了v-bind来绑定属性。1&lt;a v-bind:href="https://cn.vuejs.org"&gt;&lt;/a&gt; 由于v-bind使用很频繁，所以 Vue 提供了v-bind的缩写，只需要属性前面加上:。如下所示1&lt;a :href="https://cn.vuejs.org"&gt;&lt;/a&gt; 事件绑定在 Vue 中使用v-on来进行事件绑定1234567891011121314151617&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt;逆转文本&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello,Vue.js' &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split('').reverse().join('') &#125; &#125; &#125;)&lt;/script&gt; 和v-bind一样v-on也提供了缩写，可以使用@来代替v-on。如下所示1&lt;button @click="reverseMessage"&gt;逆转文本&lt;/button&gt; 表单的双向绑定文本123456789101112&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input v-model="message"/&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js' &#125; &#125;)&lt;/script&gt; 通过使用v-model就能对数据进行双向绑定了，当input标签里的内容被改变的时候，所绑定的message也会对应的改变。使用起来还是非常简单的。 多行文本12&lt;textarea v-model="message"&gt;&lt;/textarea&gt; 多行文本和单行的一样，没有太大的区别。 复选框123456789101112131415161718&lt;div id='app'&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; checkedNames: [] &#125; &#125;)&lt;/script&gt; 单选按钮1234567891011121314151617181920&lt;div id="app"&gt; &lt;input type="radio" value="Jack" v-model="name"/&gt; &lt;label&gt;Jack&lt;/label&gt; &lt;br/&gt; &lt;input type="radio" value="John" v-model="name"/&gt; &lt;label&gt;John&lt;/label&gt; &lt;br/&gt; &lt;input type="radio" value="Mike" v-model="name"/&gt; &lt;label&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;选择了: &#123;&#123; name &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: "#app", data: &#123; name: '' &#125;&#125;)&lt;/script&gt; 选择列表1234567891011121314151617&lt;div id="app"&gt; &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; selected: '' &#125;&#125;)&lt;/script&gt; v-model除了上面的基本用法，还提供了修饰符的功能。 .lazylazy会把原来的input事件改为change事件，只有当文本的内容发生了变化，才会同步数据。1&lt;input v-model.lazy="message"/&gt; .numbernumber修饰符会将输入的自动转为Number类型。1&lt;input v-model.number="message" type="number"/&gt; .trimtrim修饰符会自动过滤首尾的空格。1&lt;input v-model.trim="message"/&gt; 参考Vue 官网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之urllib]]></title>
    <url>%2F2017%2F11%2F03%2FPython%E4%B9%8Burllib%2F</url>
    <content type="text"><![CDATA[之前用 Python 写的一个爬虫，现在用 Emacs 打开，提示找不到urllib.urlopen这个函数。调试了半天，就是提示找不到这个函数，但是这个爬虫却能正确执行。于是我打开Dash查看其 API，发现 API 中有这个函数，但是却不是使用urllib.urlopen来调用。而是变成了urllib.request.urlopen，仔细一看当前查看的是 Python3 的版本，看来是 Python 版本的锅。 urllib 简单介绍urllib 是 Python3 中的标准网络请求库，使用 urllib 来获取网页的内容非常方便。在 Python2.x 版本中有 urllib 和 urllib2，但是到了 Python3 中 urllib 和 urllib2 被合并成了 urllib，所以之前在 Python2 中的写法就不能再出现在 Python3 中了。Python3 是趋势，所以折腾吧，少年。 先来看一下urllib 文档,从文档中可以看出 urllib 中主要有 request、error、parse、robotparser 四个模块，还是比较简单的，我们只介绍 request 其它的就不做介绍。 简单使用1234from urllib import requestres = request.urlopen('http://www.baidu.com')print(res.read().decode('utf-8')) 使用urlopen可以非常方便的以GET方式请求网页。运行代码就能看到百度首页的代码了。 添加请求参数既然用urlopen可以非常方便的请求网页，如果要携带一些参数怎么办？使用GET方式添加请求参数只需要在 url 后面拼接就可以，但是不要忘记对参数进行编码。在 Python2 中GET参数使用的是urllib.urlencode,到了 Python3 这个函数被放到了 urllib 的 parse 中。12345678from urllib import requestfrom urllib import parseq = &#123; 'wd':'python'&#125;url = 'http://www.baidu.com/s?'+parse.urlencode(q)res = request.urlopen(url)print(res.read().decode('utf-8')) 提交数据常用的 http 请求方式除了GET外还有POST。POST通常用来提交数据给服务器。urllib 也提供了非常方便的方式来提交数据。12345678910import urilib.parseimport urllib.requesturl = "http://127.0.0.1:8080"form = &#123; 'username':'jake'&#125;data = bytes(parse.urlencode(form), encoding='utf8')res = request.urlopen(url, data=data)print(res.read().decode('utf-8')) 进阶urlopen除了可以直接添加 url 外，还可以使用Request来定制请求。 Request 的使用1234import urllib.requestreq = request.Request('http://www.baidu.com')res = request.urlopen(req)print(res.read().decode('utf-8')) 上面的例子和使用 urlopen 是一样的效果。不同地方在于 request 可以进行定制。比如：请求头。 添加请求头1234567from urllib import requestheaders=&#123;'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36'&#125;req = request.Request('http://www.baidu.com',headers = headers)res = request.urlopen(req)print(res.read().decode('utf-8')) 下面这种方式也是可以的1234567from urllib import requestreq = request.Request('http://www.baidu.com')req.add_header('User-Agent','Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.75 Safari/537.36')res = request.urlopen(req)print(res.read().decode('utf-8')) COOKIE有些操作需要验证，如果每次使用都要验证，那就太麻烦了。所以我们需要把 cookie 保存下来，不要每次都去验证。1234567891011from urllib import requestimport http.cookiejarcookie = http.cookiejar.CookieJar()handler = request.HTTPCookieProcessor(cookie)opener = request.build_opener(handler)res = opener.open('http://www.baidu.com')print(res.read().decode('utf-8'))for item in cookie: print(item.name,':',item.value) 下载文件有时候碰到一些资源想保存到本地，可以使用urlretrieve来把对应的资源下载到本地,也是很方便的。123from urllib import requestrequest.urlretrieve('http://www.baidu.com/img/bd_logo1.png','logo.png') urlretrieve第一个是资源的url,第二个是保存在本地的路径和文件名，如果没有填写第二个参数则保存为临时文件。 设置代理临时代理在一些特殊的情况下你想访问某个网站，但是你访问不到，另外一台主机可以。所以这台主机可以作为一台代理电脑，由它去访问我们访问不到的网站。通常爬虫被封了，就需要用到代理。123456789from urllib.request import ProxyHandler,build_openerhandler = ProxyHandler(&#123; 'http':'填上代理地址'&#125;)opener = build_opener(handler)res = opener.open('http://www.baidu.com')print(res.read()) 代码还是很少的，只要用代理创建一个opener，然后使用opener就可以访问到网站了。除了使用 ProxyHandler 之外还有 HTTPHandler 等，可以根据自己的需要选择需要的使用。 全局代理123456789101112from urllib.request import ProxyHandler,build_opener,Requestimport urllibhandler = ProxyHandler(&#123; 'http':'代理地址'&#125;)opener = build_opener(handler)urllib.request.install_opener(opener)req = Request("http://www.baidu.com/")res = urllib.request.urlopen(req)print(res.read()) 全局代理使用urllib.request.install_opener(opener)把代理注册到全局，这样就能让所有的请求都通过代理。如果请求每次都要使用代理，那么使用全局代理会省事不少，不必每次都创建代理。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative入门]]></title>
    <url>%2F2017%2F10%2F21%2FReactNative%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React Native 在本文使用 RN 代替，代码使用 ES6 语法。 开发环境搭建Node 的安装brew install node 安装脚手架npm install -g create-react-native-app 使用脚手架创建一个 RN 项目,并运行123create-react-native-app RNDemocd RNDemonpm start 稍等片刻，成功启动之后会显示一张二维码，可以扫描这个二维码安装 App。当然也可以输入i启动iOS模拟器，或者a启动安卓模拟器。在模拟器中找到Expo这个 App，打开后可以看到如下界面，说明开发环境搭建成功了。 直接运行并启动 Android 模拟器npm run android 直接运行并启动 iOS 模拟器npm run ios 组件组件中有两个重要的字段分别是 props 和 state。props 用来和父组件之间通信，state 用来保存数据和状态。通常 props 和 state 发生变化时，会改变 UI。 Props（属性）props 在构造方法中初始化，props 不可以被自己更改。12345678910111213141516171819class Greeting extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; //传递 props &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125; State（状态）state 表示组件的状态，状态可以被自己改变，通常用来保存数据。state 在构造方法中初始化，使用setState来改变它的值，每次修改 state 会触发render来重新渲染界面。1234567891011121314151617181920class Blink extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;showText: true&#125;; // Toggle the state every second setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123; showText: !previousState.showText &#125;; &#125;); &#125;, 1000); &#125; render() &#123; let display = this.state.showText ? this.props.text : ' '; return ( &lt;Text&gt;&#123;display&#125;&lt;/Text&gt; ); &#125;&#125; 生命周期先看一下大神做的图从上图看出整个组件的生命周期分为三个阶段 创建阶段 defaultPropsdefaultProps 会在所有方法之前初始化。如果父组件没有给 props 中的某个属性赋值，则使用这里的默认值。之后把值赋给 props ,所有的对象共享 defaultProps。 constructor构造方法用于初始化 state。 componentWillMount在组件被挂载之前调用，在生命周期中只被调用一次。可以用于初始化网络数据。 render渲染组件，必须要有的方法。只能返回一个直接子元素。 componentDidMount在渲染后调用，表示组件已经加载完毕。 运行阶段 componentWillReceiveProps在组件收到新的 props 的时候调用，可以调用 setState 来更新 state，在这个方法里调用并不会触发 render。 shouldComponentUpdate在收到 props 后会调用该方法，来判断是否需要重新渲染组件。返回 true 表示要重新渲染，false 不渲染。 componentWillUpdate在重新渲染组件之前调用,在这个方法中不能调用 setState 来设置 state。 componentDidUpdate在组件重新渲染完毕后调用,不应该在这个方法中调用 setState 来设置 state，否则可能导致循环调用。 销毁阶段 componentWillUnmount组件从 DOM 中移除的时候调用，通常做一些清理工作。 布局在 React Native 中使用 Flexbox 来进行布局。Flexbox 是 W3C 在 2009 年推出的一种新的布局方案。没有 Flexbox 的时候布局写起来特别不舒服（个人觉得），比如：垂直居中。有了 Flexbox 之后再也不想使用过去的布局方式了。这里的 Flexbox 和 web 上的基本一致，有些许不同。比如：flexDirection的默认值是column而不是row。布局中使用flexDirection、alignItems和justifyContent这三个的组合就能够正确的完成布局。 Flex DirectionflexDirection 表示布局的主轴，子元素会沿着主轴的方向排列。flexDirection 的方向有column和row表示竖直排列和水平排列。12345&lt;View style=&#123;&#123;flex:1,flexDirection:'column'&#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; column row Justify ContentjustifyContent 决定者子元素在主轴上的排列方式。justifyContent 的值有flex-start, center, flex-end, space-around, 和space-between。12345&lt;View style=&#123;&#123;flex:1,justifyContent:'flex-start'&#125;&#125;&gt; &lt;View style=&#123;&#123; width:50,height:50,backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123; width:50,height:50,backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123; width:50,height:50,backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; flex-start 主轴开始对齐，也就是从主轴起点开始排列 flex-end 主轴结束方向对齐，也就内容与是主轴结束点对齐 center 居中 space-around 每个项目之间间隔相等 space-between 每个项目之间的两边都相等 Align ItemsalignItems 决定者子元素在次轴上的排列方式。alignItems 的值有flex-start, center,flex-end, 和stretch。 flex-start 内容与次轴开始对齐 flex-end 内容与次轴结束点对齐 center 内容居中 stretch 在次轴方向上展开至填满次轴，子元素控件不能在次轴上设置大小，不让会没有效果12345&lt;View style=&#123;&#123;flex:1,alignItems: 'stretch'&#125;&#125;&gt; &lt;View style=&#123;&#123; height:50,backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123; height:50,backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123; height:50,backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; 网络fetchRN 提供了fetchAPI 来进行网络请求，第二个参数可以指定 header 参数，和提交的数据。1234567891011fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;)&#125;) fetch 返回的是一个 Promise，这样我们可以很方便的处理返回的数据12345678910 function getMoviesFromApiAsync() &#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; return responseJson.movies; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;);&#125; 在 RN 中使用 ES7 标准的 async/await语法也是可以的123456789async function getMoviesFromApi() &#123; try &#123; let response = await fetch('https://facebook.github.io/react-native/movies.json'); let responseJson = await response.json(); return responseJson.movies; &#125; catch(error) &#123; console.error(error); &#125;&#125; XMLHttpRequest除了fetchAPI 外，RN 还内置了 XMLHttpRequest，也就是我们俗称ajax的东西。123456789101112131415var request = new XMLHttpRequest();request.onreadystatechange = (e) =&gt; &#123; if (request.readyState !== 4) &#123; return; &#125; if (request.status === 200) &#123; console.log('success', request.responseText); &#125; else &#123; console.warn('error'); &#125;&#125;;request.open('GET', 'https://mywebsite.com/endpoint/');request.send(); WebSocketRN 还提供了 WebSocket 的支持123456789101112131415161718192021var ws = new WebSocket('ws://host.com/path');ws.onopen = () =&gt; &#123; // connection opened ws.send('something'); // send a message&#125;;ws.onmessage = (e) =&gt; &#123; // a message was received console.log(e.data);&#125;;ws.onerror = (e) =&gt; &#123; // an error occurred console.log(e.message);&#125;;ws.onclose = (e) =&gt; &#123; // connection closed console.log(e.code, e.reason);&#125;;]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openSUSE 下安装 Parallels Tools]]></title>
    <url>%2F2017%2F09%2F18%2FopenSUSE%E4%B8%8B%E5%AE%89%E8%A3%85Parallels-Tools%2F</url>
    <content type="text"><![CDATA[Parallels Desktop 是 macOS 上一款优秀的虚拟机软件，支持各种操作系统。然而想要在其上面愉快的使用桌面操作系统，还需要在虚拟机上安装 Parallels Tools 这个工具。在 Windows 上和 Ubuntu 以及 Centos 上安装还是非常简单，然而我在 openSUSE 上尝试却失败了，寻找良久才找到解决方法。遂以此文纪念我踩过的坑，以便给后人提供参考，而不会错过一些美好的事情。 安装 Parallels Tools 初试在 Parallels Desktop 上成功安装好 openSUSE 后，把 Parallels Tools 挂载到系统（不要和我说你不知道怎么操作）。进入挂载的目录，并执行安装程序12cd /run/media/$USER/Parallels Tools/ #$USER 为你的用户名，不知道什么也没关系，一般/run/media/下就只有一个目录，就是它sudo ./install 输入密码等待程序启动，点击 next 等一小会,出现如下如所示，点击 next 安装。等待一杯咖啡的时间，如果一杯喝完没有提示安装失败，就再喝一杯。两杯咖啡下肚，终于出现如下错误它告诉我安装失败了，去/var/log/parallels-tools-install.log下看更多的信息。直觉告诉我看了可能也没什么用。不过还是去看看。 打开文件，映入眼帘，这么明显（此处略去后面的提示）它告诉我dkms找不到，据我以前安装 Ubuntu 的经验很可能是这货的问题，于是安装dkms。 安装 dkms在终端中输入1sudo zypper in dkms 提示找不到这个软件包，估计 Parallels Tools 也是调用这条命令安装的吧，所以安装失败。 既然没有，我们只好从别的地方找一个，在官方软件包中搜索 dkms ，还真找到了点击一键安装，待安装好 dkms 之后，重新执行上一小节的操作。换来的还是一样的结果，安装失败。于是我决定重启系统再安装一次，结果还是一样，一点都不意外。心灰意冷的我不断在网上找相关的问题，一次一次的尝试，结果总是那么的相似，都没有找到解决方法。直到我在 美丽新世界：linux 下的惬意生活寻找答案的时候，偶然看了一下开机过程，发现了解决问题的契机。 发现问题在美丽新世界：linux 下的惬意生活这篇文章中说道 kernel-default 是系统默认版内核。 kernel-desktop 在 kernel-pae 基础上针对桌面进行优化，并屏蔽了只有服务器上才会使用的内核功能，提升启动速度和响应速度 于是我在开机的时候观察到openSUSE 默认的果然是 kernel-default 的内核。尝试一下 kernel-desktop 兴许会成功。于是便尝试安装 kernel-desktop 的内核。 尝试解决在默认的源里是没有 kernel-desktop 的安装包，还需要使用如下命令把他添加进去,并安装 kernel-desktop123sudo zypper ar http://download.opensuse.org/repositories/home:/Ledest:/kernel:/lts/openSUSE_Leap_42.3/ kdsudo zypper refresh # 提示是否信任的时候选择 t 回车sudo zypper in kernel-desktop 第一次安装 kernel-desktop 可能会提示失败，输入r回车，重试一遍（也许多遍）就可成功。安装之后重启系统现在默认就是从 kernel-desktop 启动了。启动之后尝试安装 Parallels Tools ，居然成功了。不过没有安装 dkms 它还是推荐安装一下，说明 dkms 不是必须的。之前的错误提示，成功的误导了我。我表示很无奈。安装成功后，终于可以愉快的玩耍了。 总结 安装好系统后，先不要安装 Parallels Tools。 直接安装 kernel-desktop。 安装好 kernel-desktop 后再安装 Parallels Tools。 参考链接软件包美丽新世界：linux 下的惬意生活]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>openSUSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git Submodule 管理多个仓库]]></title>
    <url>%2F2017%2F09%2F02%2FGit-Submodule%2F</url>
    <content type="text"><![CDATA[开发中常常碰到在项目中需要使用另一个项目，这个项目不定期更新。而且我们想要保持对这个项目的更新，通常的做法是在项目中创建一个目录来单独存放这个项目，然后不定期更新这个项目。这样的做法确实可行，但是却不是最优雅的。在 Git 中有Git Submodule这个工具，它可以将另一个项目克隆到当前项目，并作为当前项目的子目录，并且保持提交独立。 简介Git Submodule翻译过来就是子模块的意思，其作用就是在一个Git仓库中管理一个或多个项目中使用到的额外的仓库。 使用 Git Submodule 添加子模块1git submodule add [url] [path]//不加 path 会在当前目录下添加子模块 在使用 Git Submodule 之后，会在仓库下生成一个.gitmodules的文件。该文件保存了项目子模块的远程仓库的路径与本地目录的映射关系。 克隆含有子模块的项目如果别人的项目中也包含了子模块，该怎么保持别人子模块也同步？123git clone [url]git submodule initgit submodule update 怎么这么多命令，有没有简单点，一步到位的？还真有。1git clone --recursive [url] 拉取子模块上游更新子模块更新了，我们想保持代码是最新的。进入到子模块中，使用git fetch和git merge来更新子模块。就这样也好意思拿出来说？太 LOW 了，不能有点新花样吗？这样每次都要进入子模块确实很麻烦，不过 git 提供了一个快速更新子模块的命令，可以不进入子模块就可以更新子模块。1git submodule update --remote 仓库名//如果不写仓库名，默认会更新所有子模块。 修改子模块的内容git submodule update会更新子模块中的文件，但是会将子模块留在一个称作『游离的 HEAD』的状态。这意味着没有本地分支跟踪改动，所以所做的任何改动都不会被跟踪。为了能够在子模块中修改内容，需要做两步操作 进入子模块，检出一个分支 1git checkout master 合并上游分支来更新本地代码 1git submodule update --remote --merge 除了用--merge来合并代码，也可以使用--rebase来同步代码。如果忘记使用--merge或者--rebase来合并代码，Git 会将子模块更新为远程仓库的状态，并重置为游离的HEAD状态。如果要合并修改过得代码，只需要再次检出你修改过的分支，并进行合并就可以了。 推送子模块的改动到远程仓库通常我们改动了子模块的内容，要让其他人员也能及时更新，我们需要把修改的内容推送到远程仓库。只需要在主仓库推送时添加--recurse-submodules=check参数，该命令会在推送的时候检查子模块的改动是否有更新到远程仓库，没有的话推送会失败。完整命令如下1git push --recurse-submodules=check 除了检查子模块有没有推送到远程仓库外，还有另一种推送方法。就是在推送是添加--recurse-submodules=on-demand,该命令会尝试把没有推送到远程仓库的子模块推送到远程仓库。如果没有冲突则推送成功，如果有冲突需要解决冲突后才能推送成功。完整命令如下1git push git push --recurse-submodules=on-demand 多个子模块操作有时候一个项目中可能包含多个子模块，但我只需要同步子模块的内容，如果每个都要操作一次，子模块少还好，但是多了操作就会花费很多时间，所以要学会偷懒，而 Git 有个foreach的子模块命令就可以在每一个子模块中运行形同的命令。例如：1git submodule foreach git checkout master 参考Pro Git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tmux]]></title>
    <url>%2F2017%2F06%2F18%2FTmux%2F</url>
    <content type="text"><![CDATA[做开发经常需要在各种环境中切来切去，回来的时候环境已经变了。Tmux 可以创建多个会话在不同环境中切换，回来的时候还是那个她，熟悉的味道。 什么是Tmux来自 Tmux 自述 tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux may be detached from a screen and continue running in the background, then later reattached. 说人话Tmux 是终端复用器，它使多个终端被创建，访问，并从单一屏幕控制。Tmux 可以从屏幕分离并继续在后台运行，然后重新连接。 有什么用举个例子：你连上服务器后做了一会事情要回到本地做一些操作，通常做法是先断开服务器的连接，做完本地操作后再连上服务器继续操作。这样做太费事了。Tmux 就是解决这件事的，它可以让你不需要断开连接就可以在本地做你想做的，就算意外断开连接也能恢复。(当然关机就不行了，但是你可以通过写脚本来恢复) 怎么用名词解释Session：用来管理窗口的，一个 Session 可包含多个 Window。Window：当前正在操作的窗口，一个 window 可包含多个 pane。Pane：window 被分割后的小窗口。Prefix：前缀键CTRL+b，表示同时按下 CTRL 和 b。下文使用 Prefix 代替 CTRL+b 安装Macbrew install tmux Linux（Ubuntu）sudo apt install tmux 基本使用安装好 Tmux 后在终端中输入tmux就可以开始使用，默认会创建一个 Session。 可以使用tmux new -s name在创建 Session 的时候并命名,name就是该 Session 的名字 Session 相关 新建 SessionPrefix :new -s name 其中name是 Session 的名字，这条指令是在Tmux的环境中使用，和基本使用中的不一样。这条指令表示先按下Prefix（CTRL+b），松开之后再输入:new -s name。后面以此类推。 列出当前 SessionPrefix s,在终端环境中使用tmux ls查看 暂时离开 SessionPrefix d 接入之前的 Session tmux a -t name,只有一个 Session 的时候可以省略name（终端环境中） 重命名 SessionPrefix $ 关闭 Session Prefix :kill-session -t name Window 相关 新建 Window Prefix c 列出当前 Window Prefix w 重命名当前 Window Prefix , 关闭 Window Prefix &amp; 上一个 Window Prefix p 下一个 Window Prefix n Pane 相关 水平分割 Window Prefix &quot; 垂直分割 Window Prefix % 关闭 Pane Prefix x 把 Pane 最大化 / 最小化 Prefix z 把 Pane 移动到左边 Prefix { 把 Pane 移动到右边 Prefix } 切换到下一个 Pane Prefix o Tips 显示时间 Prefix t 参考Tmux - Linux从业者必备利器 优雅地使用命令行：Tmux 终端复用]]></content>
      <categories>
        <category>工具 效率</category>
      </categories>
      <tags>
        <tag>工具 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派入门]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[树莓派的简单介绍 Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI)是为学生计算机编程教育而设计，只有信用卡大小的卡片式电脑，其系统基于Linux。—— 来自百度百科的介绍 安装前准备 树莓派一个（当然你要有电源适配器，没有的话移动电源也可以） SD 卡一张，树莓派使用 SD 卡作为容量，没有的 SD 卡是没法用的。（SD 卡要自己想办法连上电脑，用来烧写系统） 网线一根，用于设置 WiFi 镜像的选择镜像下载地址在地址中选择一个合适的镜像下载到本地，我选择的是 Raspbian 制作系统（MacOS 环境下制作） 在制作之前先看看有哪些磁盘diskutil list 把 SD 卡连接电脑，SD 卡需要 FAT32 格式的 再使用diskutil list查看一下多出来的就是我们要的。例如 /dev/disk2 使用diskutil unmountDisk /dev/disk&lt;disk# from diskutil&gt;来卸载分区，其中&lt;disk# from diskutil&gt;是 SD 卡的分区，不是disk2之类的，而是类似disk2s1这样的。 使用sudo dd bs=1m if=~/Downloads/2017-04-10-raspbian-jessie.img of=/dev/disk2把镜像拷贝到 SD 卡。其中if后面接的是镜像的路径，of接的是 SD 卡的路径，要根据自己镜像和 SD 卡的位置填写。bs（block size）后面接的是块的大小，照着写不必理会。这个过程比较久，需要耐心等待。 开机并使用 SSH 远程登录 把 SD 卡装进树莓派、并接上网线，并通电。 树莓派默认的账号是pi,密码是raspberry 登录之前需要知道树莓派的 IP 地址，可以使用arp -a来查看（多试几次），如果你可以登录路由器后台也可以很方便的查看到树莓派的 IP。 在终端中输入ssh pi@ip，ip就是上一步获取到的，如果你直接这样连接恐怕是连不上的。最新的 Raspbian 镜像默认禁用了 SSH 服务。开启 SSH 很简单只要在 SD 卡的根目录建立一个ssh的文件夹就行了。 配置 WiFi编辑etc/wpa_supplicant/wpa_supplicant.conf,在文件后面追加123456network=&#123; ssid="WIFINAME" # WIFI 的名字 psk="password" # WIFI 的密码 key_mgmt=WPA-PSK # 加密类型，照着写好了，一般不用改。如果想看的话，用手机连上该 WIFI 详细里面的安全性就指的是这个。 priority=1 # 连接的优先级，数值越大，优先级越高。&#125; 写好保存，重启生效]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 使用小记]]></title>
    <url>%2F2017%2F04%2F22%2FDocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Docker 简介Docker 是一个开源的应用容器引擎。可以看成是一个特殊的环境，隔离了宿主机（电脑）和容器。做开发的时候通常会碰到在自己的电脑上没问题，放到服务器或者别人的电脑上就出问题了，通常我们会认为是环境不一致导致的，调试起来非常耗时费力。有了 Docker 这些问题迎刃而解。经常在 Linux 上做测试的人员，做完测试就不用了。在过去我们会使用虚拟机，这样做不但占据者比较大的磁盘空间，而且运行启动耗时较长，性能不高。但是用 Docker 却可以随时随地启动一个 Linux 的容器，用完就可以删除，下次要用在重新开启一个新的，速度非常快。 Docker 比虚拟机来的轻巧，开启和关闭非常迅速，占用的资源少。既然 Docker 有那么多的好处，没有理由不去调戏它。 Docker 安装（Ubuntu 16.04）安装之前卸载旧版本（如果有的话）1sudo apt-get remove docker docker-engine docker.io 这里介绍两种安装方式，随便选一种都行，建议第一种，免于在安装上花费太多时间。 使用阿里云提供的安装脚本（由于网络问题，你懂得）1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - Docker 需要安装在 64 位的 x86 平台或 ARM 平台上（如树莓派），内核版本不低于 3.10。 手动安装12345678910111213sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"sudo apt-get updatesudo apt-get install docker-ce# 启动sudo systemctl start docker# 查看 docker 版本docker --version 小试牛刀，运行一个容器1docker run hello-world 建立 Docker 用户组为什么要建立 Docker 用户组 默认情况下，只有 root 用户和 docker 组的用户才可以访问 Docker。在使用中一般不会直接使用 root 用户操作，也避免每次输入命令都要加su。 建立 docker 组sudo groupadd docker 将当前用户加入 docker 组：sudo usermod -aG docker $USER Docker 名词解释镜像(Image)Docker 镜像可以理解为模板，就像面向对象里的class一样可以通过这个类创建出无数个对象（容器）。 容器(Container)Docker 容器就是通过镜像创建出来的运行实例，与面向对象里的对象类似。不过容器可以作为新的镜像用来创建新的容器。 仓库(Registry)Docker 仓库是一个镜像的集合，里面放了许多常用的镜像，不要我们自己去构建这些镜像。比如 Ubuntu、Tomcat等。一个仓库可能包含不同版本的镜像，在镜像仓库里不同的版本会被打上不同的标签。我们可以通过镜像名:标签来获取不版本的镜像。以 Ubuntu 为例，Ubuntu 16.04 的版本表示为ubuntu:16.04。如果没有写标签，表示使用最新的。即ubuntu:latest 使用镜像的管理 查看所有镜像 1docker images 获取镜像，Docker Registry 默认为 Docker Hub，镜像名由用户名/软件名组成，不写用户名默认为library，也就是官方镜像 1docker pull [Docker Registry]&lt;镜像&gt;:&lt;标签&gt; 删除镜像 1docker rmi &lt;镜像&gt; 容器的使用与管理 查看所有容器,包括没有在运行的 1docker ps -a 运行容器 1docker run ubuntu 运行交互式容器,i交互是操作，t终端。后面的bash表示用bash做为交互式终端的shell 1docker run -it ubuntu bash 运行完容器后删除,不保留运行的结果 1docker run -rm ubuntu 运行容器，并指定端口映射。p小写 1docker run -p 8080:8080 nginx 运行容器，随机映射端口。P大写 1docker run -P nginx 为容器起一个别名 1docker run --name alias nginx 后台运行容器。容器是否长久运行和-d无关，-d只是指定了运行在后台（background）。容器长久运行和run指定的命令有关。后台运行可以在本地和容器之间来回切换。 1docker run -d ubuntu 进入后台运行的容器 1docker attach ubuntu 停止容器 1docker stop ubuntu 删除容器 1docker rm ubuntu 参考Docker — 从入门到实践]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Mac 终端中使用代理]]></title>
    <url>%2F2017%2F03%2F09%2F%E5%9C%A8mac%E7%BB%88%E7%AB%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[作为一个程序员，天天和终端打交道。可是在 Mac 终端下使用 brew 安装软件却十分慢，即便你使用 ShadowSocks 配置了全局代理，却发现这么做依然没有效果，下载还是龟速。虽然可以通过配置国内的镜像来解决，但是后期下载还是很慢，效果就不好了。 简单使用在终端使用 ShadowSocks 十分简单，只需在终端中输入下列指令就可1export ALL_PROXY = socks5://127.0.0.1:1080 现在可以试试 brew 更新软件了，速度蹭蹭的往上涨 不想用代理了，输入下面指令即可1unset ALL_PROXY 优化每次想要使用代理的时候都要输入这么多记不住把下面的命令保存到 ~/.bash_profile 如果使用的是zsh则保存到 ~/.zshrc12alias socks5 = "export ALL_PROXY=socks5://127.0.0.1:1080"alias unsocks5 = "unset ALL_PROXY" 想要立即生效 source .zshrc 或者 source .bash_profile以后想要打开代理只需输 socks5关闭只需输 unsocks5]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络服务发现（NSD）]]></title>
    <url>%2F2016%2F10%2F03%2FAndroid%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这些日子碰到这样一个需求，需要在局域网中发现我们创建的某个特定设备，并连上互相通信。本以为要去遍历整个局域网，后来查阅相关资料后发现 Android 为我们提供了网络服务发现（Network Service Discovery）简称 NSD，就是本文要讲的东西了。 NSD 有什么用用来扫描局域网中特定的服务，并与之通信。省去了自己去写发现协议。 NSD 怎么用创建我们需要提供的服务首先要创建一个 ServerSocket，用来等待别人的连接123456789101112/** *创建一个server来获取端口 */private void createServerSocket() &#123; if (mServerSocket != null) return; try &#123; mServerSocket = new ServerSocket(0);//设为0,会自动获取没有占用的端口 mPort = mServerSocket.getLocalPort(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 接下来就可以创建 NsdServiceInfo 了，NsdServiceInfo 是一个包含 Nsd 服务信息的类,看名字就知道了。12345678910/** *创建NsdServiceInfo */private void createNsdServiceInfo() &#123; if (mNsdServiceInfo != null) return; mNsdServiceInfo = new NsdServiceInfo(); mNsdServiceInfo.setServiceName(SERVICE_NAME);//设置服务的名字，被别的机器发现时显示的名字。 mNsdServiceInfo.setServiceType(SERVICE_TYPE); mNsdServiceInfo.setPort(mPort);&#125; 在服务端注册 NSD 服务12345678910111213141516171819202122232425private void register() &#123; mNsdManager = (NsdManager) getSystemService(NSD_SERVICE); mNsdManager.registerService(mNsdServiceInfo, NsdManager.PROTOCOL_DNS_SD,mRegistrationListener);&#125;private void createRegistration() &#123; mRegistrationListener = new NsdManager.RegistrationListener() &#123; @Override public void onRegistrationFailed(NsdServiceInfo nsdServiceInfo, int i)&#123; Toast.makeText(MainActivity.this, "onRegistrationFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUnregistrationFailed(NsdServiceInfo nsdServiceInfo, int i) &#123; Toast.makeText(MainActivity.this, "onUnregistrationFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceRegistered(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceRegistered", Toast.LENGTH_SHORT).show(); new Thread(MainActivity.this).start(); &#125; @Override public void onServiceUnregistered(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceUnregistered", Toast.LENGTH_SHORT).show(); &#125; &#125;;&#125; 在客户端发现 NSD 服务12345678910111213141516171819202122232425262728293031nsdManager.discoverServices(SERVICE_TYPE, NsdManager.PROTOCOL_DNS_SD, mDiscoveryListener);private void createDiscoverListener() &#123; mDiscoveryListener = new NsdManager.DiscoveryListener() &#123; @Override public void onStartDiscoveryFailed(String s, int i) &#123; Toast.makeText(MainActivity.this, "onStartDiscoveryFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onStopDiscoveryFailed(String s, int i) &#123; Toast.makeText(MainActivity.this, "onStopDiscoveryFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDiscoveryStarted(String s) &#123; Toast.makeText(MainActivity.this, "onDiscoveryStarted", Toast.LENGTH_SHORT).show(); &#125; @Override public void onDiscoveryStopped(String s) &#123; Toast.makeText(MainActivity.this, "onDiscoveryStopped", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceFound(NsdServiceInfo nsdServiceInfo) &#123; //这里的nsdServiceInfo只能获取到名字,ip和端口都不能获取到,要想获取到需要调用NsdManager.resolveService方法 datas.add(nsdServiceInfo); mHandler.sendEmptyMessage(0); &#125; @Override public void onServiceLost(NsdServiceInfo nsdServiceInfo) &#123; Toast.makeText(MainActivity.this, "onServiceLost", Toast.LENGTH_SHORT).show(); &#125; &#125;;&#125; 获取服务的详细信息1234567891011121314nsdManager.resolveService(nsdServiceInfo, mResolverListener);private void createResolverListener() &#123; mResolverListener = new NsdManager.ResolveListener() &#123; @Override public void onResolveFailed(NsdServiceInfo nsdServiceInfo, int i) &#123; Toast.makeText(MainActivity.this, "onResolveFailed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceResolved(NsdServiceInfo nsdServiceInfo) &#123; mNsdServiceInfo = nsdServiceInfo; new Thread(MainActivity.this).start(); &#125; &#125;;&#125; 连接1234mSocket = new Socket(mNsdServiceInfo.getHost().getHostAddress(), mNsdServiceInfo.getPort());bufferedWriter = new BufferedWriter(new OutputStreamWriter(mSocket.getOutputStream()));bufferedWriter.write("我连上你了!" + "\n");bufferedWriter.flush(); 效果图 相关资料链接 demo地址 官网资料需自备梯子]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言开发环境搭建]]></title>
    <url>%2F2016%2F08%2F12%2FGo%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Go语言简介Go 是一门开源，在语言层上支持并发，带垃圾回收的新型编译型语言。具有动态语言的开发效率，静态语言的安全性。Go 语言是 Google 开发的，Go 语言的主要作者都是牛逼到不行的人物。比如： 肯·汤普逊(Ken Thompson):C 语言的设计者，Unix 操作系统的创建者，并于 1983 年获得图灵奖。 罗布·派克:Unix 小组的成员，《Unix编程环境》作者之一。 罗伯特·格里泽默(Robert Griesemer)参与 Java 的 HotSpot 编译器和 Chrome 浏览器的 JavaScript 引擎 V8 的制作。有这么多牛逼哄哄的人物镇楼，Go 语言的表现注定不会平庸。 安装Mac 下安装 使用homebrew安装，如果不知道homebrew是什么，请使用搜索解决。1brew install go Linux（Ubuntu）下安装 下载安装包下载地址在下载地址中根据自己电脑的系统选择对应的下载 解压下载的安装包到/usr/local1tar -C /usr/local/ -xzf go$VERSION.$OS-$ARCH.tar.gz #把`go$VERSION.$OS-$ARCH.tar.gz`换成你下载的文件名 如果提示没有权限在最前面加上sudo 配置环境变量 编辑vi ~/.bashrc，如果没有自己手动创建。在文件的末尾加入下面的语句。 123456789# 下面两句只需要选择一句配置，根据自己系统选择对应的食用export GOROOT=/usr/local/opt/go/libexec # Mac 下使用`homebrew`安装的配置export GOROOT=/usr/local/go # Linux 下的配置# Go 命令export GOBIN=$GOROOT/bin# 加入到 PATH 中export PATH=$PATH:$GOBIN # 可以根据自己喜好设置 GOPATH 的路径。export GOPATH=/home/$USER/go GOROOT是Go语言的安装目录 GOBIN是Go语言二进制文件目录,把GOBIN加入到PATH中可以在终端中使用TAB补齐 GOPATH是Go语言的工作目录，也就是我们通常开发用到的目录.从 go 语言 1.8 开始，GOPATH 默认为$HOME/go。 使配置的环境变量立即生效 1source ~/.bashrc 验证是否安装成功 1go version 如果输出类似下面的内容则安装成功 1go version go1.8.3 darwin/amd64 GOPATH 结构 GOPATH 是 Go 语言的工作目录，在 GOPATH 下有三个重要的子目录分别是src、pkg、bin。 src存放 Go 语言的源代码 pkg存放编译后生成的文件 bin存放编译后生成的可执行文件 安装 GoSublime 插件（默认安装好了 SublimeText3）GoSublime 是 Sublime Text 3 的一个插件，装上该插件可以有代码提示的功能。 启用 package control,按下 Ctrl + ` ,输入 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 安装 GoSublime在 sublime 中同时按住 cmd + shift + p,在弹出的框中输入install package,需要等待一会搜索包，搜索完毕后在输入框中输入 gosublime ，选中第一个，回车安装好了重启生效 配置 GoSublime在菜单中选择 Preferences -&gt; package settings -&gt; GoSublime -&gt; Settings -&gt; Uesrs在打开的文件中输入 123456&#123; "env": &#123; "GOPATH": "~/go",//根据自己的路径修改 "GOROOT": "/usr/local/opt/go/libexec" &#125;&#125; 运行在 GOPATH 中新建一个 hello.go 文件，输入 12345package mainimport ("fmt")func main()&#123; fmt.Print("hello go")&#125; 在 sublime 中 按住cmd+b后输入 go run hello.go 就可以看都控制台打印了 hello go]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Hexo 搭建博客]]></title>
    <url>%2F2016%2F06%2F16%2Fhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[安装 Hexo 前环境的搭建Node.js 的安装1brew install node ps：如果没有安装 brew 请移步 Homebrew 安装 Git，当然你还得有 GitHub 账号安装过 Xcode 的可以跳过这一步，Xcode 的自带 Git。没安装的可以安装 Xcode 也可以使用下面的命令安装1brew install git 安装 Hexo12//安装到全局npm install -g hexo-cli 初始化 Hexo初始化当前目录1hexo init "文件夹" //如果文件夹为空，则为当前目录(文件夹不要带引号) 安装依赖包12//进入到上一步初始化的文件夹下npm install 配置进入到初始化的目录，打开 _config.yml1234567title: xxx #博客名字description: xxx #博客描述，给搜索引擎看的author: xxx #博客作者deploy: type: git #填git，毕竟我们发布到github上 repo: xxx #https://github.com/xxxx/xxx.github.io.git,把xxx换成你博客的名字 branch: master #要发布的分支，还可以建立一个分支开管理源码，这样就和博客区分开了 写文章新建草稿1hexo n draft "文件名" //其中draft可以选择scaffolds下的名字,scaffolds下面存放的是模板 发布草稿1hexo publish draft 文件名 // 其中draft对应scaffolds文件夹下的文件名，文件名对应要发布的文件名,只有发布的才能在博客中看到 生成页面1hexo g //完整写法hexo generate 在本地启动服务器进行预览1hexo s //完整写法hexo server 在浏览器输入 http://localhost:4000 就可以预览页面 部署到服务器1234hexo d//可能碰到如下错误//ERROR Deployer not found: git 或者 ERROR Deployer //not found: github//解决方法： npm install hexo-deployer-git --save 更新更新 hexo1npm update -g hexo 更新主题12cd themes/你的主题git pull 更新插件1npm update 参考官网文档]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>