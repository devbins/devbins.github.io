<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on devbins blog</title>
    <link>http://devbins.github.io/categories/android/</link>
    <description>Recent content in Android on devbins blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 11 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://devbins.github.io/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>小米手机解锁 bootloader</title>
      <link>http://devbins.github.io/post/%E5%B0%8F%E7%B1%B3%E8%A7%A3%E9%94%81bootloader/</link>
      <pubDate>Sun, 11 May 2025 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/%E5%B0%8F%E7%B1%B3%E8%A7%A3%E9%94%81bootloader/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;有一部 root 过的手机，在进行抓包，定位问题会方便不少，所以有必要搞一台 root 过的手机。&lt;/p&gt;&#xA;&lt;p&gt;我手上有一台小米的手机，root 之前需要解 bootloader。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JNI: HashMap&lt;-&gt;unordered_map</title>
      <link>http://devbins.github.io/post/jni_map/</link>
      <pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/jni_map/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在进行 &lt;code&gt;JNI&lt;/code&gt; 开发的时候，经常会碰到需要传递 &lt;code&gt;Map&lt;/code&gt; 的需求。&lt;/p&gt;&#xA;&lt;p&gt;它们实现起来不难，但是写起来还是比较麻烦的，每次要写的时候都要老半天。&lt;/p&gt;&#xA;&lt;p&gt;所以这里给一个参考，希望在用到的时候能帮你进行快速开发。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeakCanary 内存泄漏检测原理</title>
      <link>http://devbins.github.io/post/leakcanary/</link>
      <pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/leakcanary/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;内存泄漏是一个开发不得不面对的问题，在 Android 中有许多工具都可以用来检测内存泄漏，比如：MAT、Profile等。&lt;/p&gt;&#xA;&lt;p&gt;但是这些工具都需要手动操作，比较麻烦，所以我们需要一个能够自动检测的工具，它就是&lt;a href=&#34;https://square.github.io/leakcanary/&#34;&gt;LeakCanary&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;今天就来了解一下原理，毕竟面试也是常问的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rust For Android</title>
      <link>http://devbins.github.io/post/rust_android/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/rust_android/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;继上一篇&lt;a href=&#34;https://devbins.github.io/post/rust%5Fios/&#34;&gt;用 Rust 开发 iOS&lt;/a&gt; 开发折腾之后，我又折腾起 &lt;code&gt;Android&lt;/code&gt; 了。&lt;/p&gt;&#xA;&lt;p&gt;最开始我是先从 &lt;code&gt;Android&lt;/code&gt; 上下手的，不过一直没成功，直到最近才成功了。&lt;/p&gt;&#xA;&lt;p&gt;本文默认你已经把 &lt;code&gt;Rust&lt;/code&gt; 安装好了。注意需要使用 &lt;code&gt;stable&lt;/code&gt;  &lt;code&gt;channel&lt;/code&gt; ，我之前使用的是 &lt;code&gt;nightly&lt;/code&gt; 所以一直失败。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;nightly channel&lt;/code&gt; 会报 &lt;code&gt;dl_iterate_phdr can&#39;t find&lt;/code&gt; 错误，这个错误一直误导了我，我一直以为是链接上的问题，所以折腾了很久。&lt;/p&gt;&#xA;&lt;p&gt;直到我换了一台电脑试了一下，居然成功了，才发现使用的 &lt;code&gt;channel&lt;/code&gt; 是不一样的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android Cronet 构建</title>
      <link>http://devbins.github.io/post/cronet/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/cronet/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Cronet&lt;/code&gt; 是 &lt;code&gt;Chromium&lt;/code&gt; 浏览器中用于网络请求的库，支持 &lt;code&gt;HTTP1/2&lt;/code&gt; 、 &lt;code&gt;SPDY&lt;/code&gt; 、 &lt;code&gt;QUIC&lt;/code&gt; 等协议。并且还支持移动端。&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是编译 &lt;code&gt;Android&lt;/code&gt; 需要在 &lt;code&gt;Linux&lt;/code&gt; 下进行，并且只支持 &lt;code&gt;Ubuntu&lt;/code&gt; 和 &lt;code&gt;Debian&lt;/code&gt; 的发行版，其它的不支持。&lt;/p&gt;</description>
    </item>
    <item>
      <title>探秘 AIDL 为什么不支持 short</title>
      <link>http://devbins.github.io/post/aidl_short/</link>
      <pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/aidl_short/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;前阵子复习 &lt;code&gt;AIDL&lt;/code&gt; 相关的知识，知道 &lt;code&gt;AIDL&lt;/code&gt; 不支持 &lt;code&gt;short&lt;/code&gt; 类型，但是我却发现同样使用 &lt;code&gt;AIDL&lt;/code&gt; 的 &lt;code&gt;Messenger&lt;/code&gt; 却可以。&lt;/p&gt;&#xA;&lt;p&gt;这是怎么回事，本文将探索这其中原因。&lt;/p&gt;</description>
    </item>
    <item>
      <title>IPC 之 Messenger</title>
      <link>http://devbins.github.io/post/messenger/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/messenger/</guid>
      <description>&lt;h2 id=&#34;messenger是什么&#34;&gt;Messenger是什么?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Messenger&lt;/code&gt; 在 &lt;code&gt;Android&lt;/code&gt; 中和 &lt;code&gt;AIDL&lt;/code&gt; 一样，用于进程间通信的技术，也是基于 &lt;code&gt;AIDL&lt;/code&gt; 的封装。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Application 启动流程</title>
      <link>http://devbins.github.io/post/application/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/application/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在 &lt;a href=&#34;https://devbins.github.io/post/zygote/&#34;&gt;Zygote&lt;/a&gt; 这篇文章中提到， &lt;code&gt;Zygote&lt;/code&gt; 在收到创建新进程的请求之后，会创建新的进程，当时没有继续往下探索了，今天来探索一下 &lt;code&gt;Application&lt;/code&gt; 是如何创建的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>SystemServer</title>
      <link>http://devbins.github.io/post/systemserver/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/systemserver/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在 &lt;a href=&#34;http://localhost:1313/post/zygote/&#34;&gt;Zygote&lt;/a&gt; 这篇文章中，我们提到 &lt;code&gt;Zygote&lt;/code&gt; 会创建 &lt;code&gt;SystemServer&lt;/code&gt; 进程，当时我们没有去了解。&lt;/p&gt;&#xA;&lt;p&gt;今天就来聊一聊 &lt;code&gt;SystemServer&lt;/code&gt; 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JNI中的引用</title>
      <link>http://devbins.github.io/post/jni%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/jni%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;平时写 &lt;code&gt;Java&lt;/code&gt; 代码对创建的对象，我们很少会去关心怎么手动释放内存，大多数时候都有 &lt;code&gt;GC&lt;/code&gt; 去帮我们回收。&lt;/p&gt;&#xA;&lt;p&gt;然而在 &lt;code&gt;JNI&lt;/code&gt; 中，几乎都是 &lt;code&gt;C/C++&lt;/code&gt; 的代码，它们是没有 &lt;code&gt;GC&lt;/code&gt; 的，所以对内存的使用就需要格外小心了。&lt;/p&gt;&#xA;&lt;p&gt;因此在 &lt;code&gt;JNI&lt;/code&gt; 中提供了三种引用类型，分别是局部引用、全局引用、弱全局引用。下面介绍这三种引用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zygote 是怎么使用 LocalSocket 进行进程间通信的</title>
      <link>http://devbins.github.io/post/localsocket/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/localsocket/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;本文基于 &lt;code&gt;Android10&lt;/code&gt; ，分析 &lt;code&gt;Zygote&lt;/code&gt; 与 &lt;code&gt;AMS&lt;/code&gt; 是如何使用 &lt;code&gt;LocalSocket&lt;/code&gt; 建立连接的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zygote</title>
      <link>http://devbins.github.io/post/zygote/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/zygote/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Zygote&lt;/code&gt; 是 &lt;code&gt;Android&lt;/code&gt; 中所有 &lt;code&gt;App&lt;/code&gt; 的父进程，有着举足轻重的地位。了解了 &lt;code&gt;Zygote&lt;/code&gt; 可以让你对系统如何工作有更深入的了解，今天来学习一下 &lt;code&gt;Zygote&lt;/code&gt; 的知识。&lt;/p&gt;&#xA;&lt;p&gt;本文基于 &lt;code&gt;Android10&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Handler 之 MessageQueue</title>
      <link>http://devbins.github.io/post/handler_mq/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/handler_mq/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;上一篇文章，我们从 &lt;code&gt;Java&lt;/code&gt; 层探索了消息机制的原理，以及在使用中会碰到的问题，这一篇从 &lt;code&gt;MessageQueue&lt;/code&gt; 入手，带你了解 &lt;code&gt;Native&lt;/code&gt; 层的原理。&lt;/p&gt;&#xA;&lt;p&gt;本文源码基于 &lt;code&gt;Android10&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Handler</title>
      <link>http://devbins.github.io/post/handler/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/handler/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 在 &lt;code&gt;Android&lt;/code&gt; 中的地位不用多说了，没有消息机制则寸步难行。&lt;/p&gt;&#xA;&lt;p&gt;通常我们会使用 &lt;code&gt;Handler&lt;/code&gt; 在主线程与子线程之间通信，那么它们是怎么通信的，有什么玄机？&lt;/p&gt;&#xA;&lt;p&gt;本文会带你从 &lt;code&gt;Java&lt;/code&gt; 层的源码了解其原理，以及在使用过程中要注意的地方。下一篇则从 &lt;code&gt;Native&lt;/code&gt; 层了解背后的原理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android中管道的使用</title>
      <link>http://devbins.github.io/post/pipe/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/pipe/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;最近读了一些 &lt;code&gt;Android&lt;/code&gt; 源码，发现其中不少是用 &lt;code&gt;pipe&lt;/code&gt; 机制来实现的，并且和我们往常使用 &lt;code&gt;pipe&lt;/code&gt;  有些不一样。&lt;/p&gt;&#xA;&lt;p&gt;有必要学习一下 &lt;code&gt;pipe&lt;/code&gt; 的使用，不然会影响阅读源码，并且 &lt;code&gt;Android&lt;/code&gt; 里的使用方式比较有技巧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gradle入门</title>
      <link>http://devbins.github.io/post/gradle/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/gradle/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在前一篇文章我们讲了 &lt;code&gt;Groovy&lt;/code&gt; ，有了 &lt;code&gt;Groovy&lt;/code&gt; 的基础就能看懂 &lt;code&gt;Gradle&lt;/code&gt; 里的语法。但是光有 &lt;code&gt;Groovy&lt;/code&gt; 基础还是不够的， &lt;code&gt;Gradle&lt;/code&gt; 提供了一些 &lt;code&gt;API&lt;/code&gt; 让我们可以很方便的参与到项目的构建中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Groovy 入门</title>
      <link>http://devbins.github.io/post/groovy/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/groovy/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;在 &lt;code&gt;Android&lt;/code&gt; 中现在默认的构建工具是 &lt;code&gt;Gradle&lt;/code&gt; ，而 &lt;code&gt;Gradle&lt;/code&gt; 构建工具是使用 &lt;code&gt;Groovy&lt;/code&gt; 语言编写的，这就使得了解 &lt;code&gt;Groovy&lt;/code&gt; 语言变得非常重要了。&lt;/p&gt;&#xA;&lt;p&gt;如果你不了解 &lt;code&gt;Groovy&lt;/code&gt; 会以为 &lt;code&gt;build.gralde&lt;/code&gt; 文件中写的就只是一些配置，其实并没有这么简单。之所以看起来项配置文件，是因为 &lt;code&gt;Groovy&lt;/code&gt; 的闭包特性，让我们写起来简单，看起来像配置文件，这就降低了编写的门槛。使得我们可以专注于 &lt;code&gt;Android&lt;/code&gt; 层面的业务逻辑。&lt;/p&gt;&#xA;&lt;p&gt;随着 &lt;code&gt;Android&lt;/code&gt; 的发展，我们不能局限于应用层，在构建的过程我们也可以进行一些优化。今天就来学习一下 &lt;code&gt;Groovy&lt;/code&gt; 这们语言。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MPAndroidChart 使用总结</title>
      <link>http://devbins.github.io/post/mpandroidchart/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/mpandroidchart/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;今年开工以来，一直接触图表相关的开发，经过选择最后采用 &lt;a href=&#34;https://github.com/PhilJay/MPAndroidChart&#34;&gt;MPAndroidChart&lt;/a&gt; ，期间碰到了一些问题，踩了不少坑。特来总结一下，以免日后忘记。这些知识点虽然不难，但是非常零碎，找起来比较麻烦。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Docker下载AOSP源码</title>
      <link>http://devbins.github.io/post/aosp/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/aosp/</guid>
      <description>&lt;h2 id=&#34;aosp-介绍&#34;&gt;AOSP 介绍&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;AOSP&lt;/code&gt; 是 Android 开放源码项目，通俗点就是整个 &lt;code&gt;Android&lt;/code&gt; 的源码。有了 &lt;code&gt;AOSP&lt;/code&gt; 我们就可以在源码的层面去了解整个 &lt;code&gt;Android&lt;/code&gt; 系统。甚至可以自己基于 &lt;code&gt;AOSP&lt;/code&gt; 去定制自己系统，这也是众多 &lt;code&gt;ROM&lt;/code&gt; 的直接或间接起源。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxLifecycle 原理解析</title>
      <link>http://devbins.github.io/post/rxlifecycle/</link>
      <pubDate>Sat, 27 Jul 2019 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/rxlifecycle/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;p&gt;从名字中可以看出 &lt;code&gt;RxLifecycle&lt;/code&gt; 和生命周期有关。也的确如此， &lt;code&gt;RxLifecycle&lt;/code&gt; 通过监听生命周期的变化，来解决 &lt;code&gt;RxJava&lt;/code&gt; 内存泄漏的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retrofit 源码解析</title>
      <link>http://devbins.github.io/post/retrofit/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/retrofit/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Retrofit 是 square 推出用来请求 RESTful 风格 API 的网络库，可以让开发人员快速开发 RESTful 风格的应用。&lt;/p&gt;&#xA;&lt;p&gt;本文基于 &lt;code&gt;retrofit2.5.0&lt;/code&gt; 进行分析。&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>在 Docker 中使用 nexus3 构建 Android 私有仓库</title>
      <link>http://devbins.github.io/post/nexus3/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/nexus3/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;在 Android 中使用第三库有两种方式，第一种是把 jar 文件放到 libs 目录下作为 library 引用，第二种需要开发者把编译好的 jar 包上传到类似 maven 这种中央仓库，然后在项目中添加依赖就可以了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>在 Docker 中用 Jenkins 搭建 Android 自动化打包</title>
      <link>http://devbins.github.io/post/jenkins/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/jenkins/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Jenkins 是一个持续集成的工具，帮你构建和打包自动化，不用手动做这些操作。构建完成后可以帮你上传到第三方测试平台，或者做其他一些操作。例如：发送邮件通知测试人员可以开始测试了，邮件中包含下载地址，或者二维码。整个流程不需要手动管理，非常高效。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android 网络服务发现（NSD）</title>
      <link>http://devbins.github.io/post/nsd/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      <guid>http://devbins.github.io/post/nsd/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;这些日子碰到这样一个需求，需要在局域网中发现我们创建的某个特定设备，并连上互相通信。本以为要去遍历整个局域网，后来查阅相关资料后发现 Android 为我们提供了网络服务发现（Network Service Discovery）简称 NSD，就是本文要讲的东西了。&lt;/p&gt;&lt;/blockquote&gt;</description>
    </item>
  </channel>
</rss>
