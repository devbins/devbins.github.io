<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on devbins blog</title>
    <link>http://devbins.github.io/categories/android/</link>
    <description>Recent content in Android on devbins blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 03 May 2021 00:00:00 +0800</lastBuildDate><atom:link href="http://devbins.github.io/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Application 启动流程</title>
      <link>http://devbins.github.io/post/application/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/application/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&#34;http://localhost:1313/post/zygote/#forksystemserver&#34;&gt;Zygote&lt;/a&gt; 这篇文章中提到， &lt;code&gt;Zygote&lt;/code&gt; 在收到创建新进程的请求之后，会创建新的进程，当时没有继续往下探索了，今天来探索一下 &lt;code&gt;Application&lt;/code&gt; 是如何创建的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SystemServer</title>
      <link>http://devbins.github.io/post/systemserver/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/systemserver/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&#34;http://localhost:1313/post/zygote/&#34;&gt;Zygote&lt;/a&gt; 这篇文章中，我们提到 &lt;code&gt;Zygote&lt;/code&gt; 会创建 &lt;code&gt;SystemServer&lt;/code&gt; 进程，当时我们没有去了解。&lt;/p&gt;
&lt;p&gt;今天就来聊一聊 &lt;code&gt;SystemServer&lt;/code&gt; 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JNI中的引用</title>
      <link>http://devbins.github.io/post/jni%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/jni%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;平时写 &lt;code&gt;Java&lt;/code&gt; 代码对创建的对象，我们很少会去关心怎么手动释放内存，大多数时候都有 &lt;code&gt;GC&lt;/code&gt; 去帮我们回收。&lt;/p&gt;
&lt;p&gt;然而在 &lt;code&gt;JNI&lt;/code&gt; 中，几乎都是 &lt;code&gt;C/C++&lt;/code&gt; 的代码，它们是没有 &lt;code&gt;GC&lt;/code&gt; 的，所以对内存的使用就需要格外小心了。&lt;/p&gt;
&lt;p&gt;因此在 &lt;code&gt;JNI&lt;/code&gt; 中提供了三种引用类型，分别是局部引用、全局引用、弱全局引用。下面介绍这三种引用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zygote 是怎么使用 LocalSocket 进行进程间通信的</title>
      <link>http://devbins.github.io/post/localsocket/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/localsocket/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文基于 &lt;code&gt;Android10&lt;/code&gt; ，分析 &lt;code&gt;Zygote&lt;/code&gt; 与 &lt;code&gt;AMS&lt;/code&gt; 是如何使用 &lt;code&gt;LocalSocket&lt;/code&gt; 建立连接的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zygote</title>
      <link>http://devbins.github.io/post/zygote/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/zygote/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Zygote&lt;/code&gt; 是 &lt;code&gt;Android&lt;/code&gt; 中所有 &lt;code&gt;App&lt;/code&gt; 的父进程，有着举足轻重的地位。了解了 &lt;code&gt;Zygote&lt;/code&gt; 可以让你对系统如何工作有更深入的了解，今天来学习一下 &lt;code&gt;Zygote&lt;/code&gt; 的知识。&lt;/p&gt;
&lt;p&gt;本文基于 &lt;code&gt;Android10&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler 之 MessageQueue</title>
      <link>http://devbins.github.io/post/handler_mq/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/handler_mq/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇文章，我们从 &lt;code&gt;Java&lt;/code&gt; 层探索了消息机制的原理，以及在使用中会碰到的问题，这一篇从 &lt;code&gt;MessageQueue&lt;/code&gt; 入手，带你了解 &lt;code&gt;Native&lt;/code&gt; 层的原理。&lt;/p&gt;
&lt;p&gt;本文源码基于 &lt;code&gt;Android10&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Handler</title>
      <link>http://devbins.github.io/post/handler/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/handler/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 在 &lt;code&gt;Android&lt;/code&gt; 中的地位不用多说了，没有消息机制则寸步难行。&lt;/p&gt;
&lt;p&gt;通常我们会使用 &lt;code&gt;Handler&lt;/code&gt; 在主线程与子线程之间通信，那么它们是怎么通信的，有什么玄机？&lt;/p&gt;
&lt;p&gt;本文会带你从 &lt;code&gt;Java&lt;/code&gt; 层的源码了解其原理，以及在使用过程中要注意的地方。下一篇则从 &lt;code&gt;Native&lt;/code&gt; 层了解背后的原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android中管道的使用</title>
      <link>http://devbins.github.io/post/pipe/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/pipe/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近读了一些 &lt;code&gt;Android&lt;/code&gt; 源码，发现其中不少是用 &lt;code&gt;pipe&lt;/code&gt; 机制来实现的，并且和我们往常使用 &lt;code&gt;pipe&lt;/code&gt;  有些不一样。&lt;/p&gt;
&lt;p&gt;有必要学习一下 &lt;code&gt;pipe&lt;/code&gt; 的使用，不然会影响阅读源码，并且 &lt;code&gt;Android&lt;/code&gt; 里的使用方式比较有技巧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gradle入门</title>
      <link>http://devbins.github.io/post/gradle/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/gradle/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在前一篇文章我们讲了 &lt;code&gt;Groovy&lt;/code&gt; ，有了 &lt;code&gt;Groovy&lt;/code&gt; 的基础就能看懂 &lt;code&gt;Gradle&lt;/code&gt; 里的语法。但是光有 &lt;code&gt;Groovy&lt;/code&gt; 基础还是不够的， &lt;code&gt;Gradle&lt;/code&gt; 提供了一些 &lt;code&gt;API&lt;/code&gt; 让我们可以很方便的参与到项目的构建中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Groovy 入门</title>
      <link>http://devbins.github.io/post/groovy/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/groovy/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;Android&lt;/code&gt; 中现在默认的构建工具是 &lt;code&gt;Gradle&lt;/code&gt; ，而 &lt;code&gt;Gradle&lt;/code&gt; 构建工具是使用 &lt;code&gt;Groovy&lt;/code&gt; 语言编写的，这就使得了解 &lt;code&gt;Groovy&lt;/code&gt; 语言变得非常重要了。&lt;/p&gt;
&lt;p&gt;如果你不了解 &lt;code&gt;Groovy&lt;/code&gt; 会以为 &lt;code&gt;build.gralde&lt;/code&gt; 文件中写的就只是一些配置，其实并没有这么简单。之所以看起来项配置文件，是因为 &lt;code&gt;Groovy&lt;/code&gt; 的闭包特性，让我们写起来简单，看起来像配置文件，这就降低了编写的门槛。使得我们可以专注于 &lt;code&gt;Android&lt;/code&gt; 层面的业务逻辑。&lt;/p&gt;
&lt;p&gt;随着 &lt;code&gt;Android&lt;/code&gt; 的发展，我们不能局限于应用层，在构建的过程我们也可以进行一些优化。今天就来学习一下 &lt;code&gt;Groovy&lt;/code&gt; 这们语言。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MPAndroidChart 使用总结</title>
      <link>http://devbins.github.io/post/mpandroidchart/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/mpandroidchart/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今年开工以来，一直接触图表相关的开发，经过选择最后采用 &lt;a href=&#34;https://github.com/PhilJay/MPAndroidChart&#34;&gt;MPAndroidChart&lt;/a&gt; ，期间碰到了一些问题，踩了不少坑。特来总结一下，以免日后忘记。这些知识点虽然不难，但是非常零碎，找起来比较麻烦。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用Docker下载AOSP源码</title>
      <link>http://devbins.github.io/post/aosp/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/aosp/</guid>
      <description>AOSP 介绍 AOSP 是 Android 开放源码项目，通俗点就是整个 Android 的源码。有了 AOSP 我们就可以在源码的层面去了解整个 Android 系统。甚至可以自己基于 AOSP 去定制自己系统，这也是众多</description>
    </item>
    
    <item>
      <title>RxLifecycle 原理解析</title>
      <link>http://devbins.github.io/post/rxlifecycle/</link>
      <pubDate>Sat, 27 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/rxlifecycle/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;从名字中可以看出 &lt;code&gt;RxLifecycle&lt;/code&gt; 和生命周期有关。也的确如此， &lt;code&gt;RxLifecycle&lt;/code&gt; 通过监听生命周期的变化，来解决 &lt;code&gt;RxJava&lt;/code&gt; 内存泄漏的问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Retrofit 源码解析</title>
      <link>http://devbins.github.io/post/retrofit/</link>
      <pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/retrofit/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Retrofit 是 square 推出用来请求 RESTful 风格 API 的网络库，可以让开发人员快速开发 RESTful 风格的应用。&lt;/p&gt;
&lt;p&gt;本文基于 &lt;code&gt;retrofit2.5.0&lt;/code&gt; 进行分析。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>在 Docker 中使用 nexus3 构建 Android 私有仓库</title>
      <link>http://devbins.github.io/post/nexus3/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/nexus3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在 Android 中使用第三库有两种方式，第一种是把 jar 文件放到 libs 目录下作为 library 引用，第二种需要开发者把编译好的 jar 包上传到类似 maven 这种中央仓库，然后在项目中添加依赖就可以了。&lt;/p&gt;
&lt;p&gt;使用 jcenter 来管理第三方库在升级版本时非常方便，只需要更改版本号就可以了。不然每次版本升级都需要到指定的地方下载下来，然后替换旧版本，这样就非常麻烦。但是 maven 是所有人员都可以访问的，有一些公司的项目是不能公开，所以需要我们搭建自己的 maven 仓库，这就是本文要讲的。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Android 网络服务发现（NSD）</title>
      <link>http://devbins.github.io/post/nsd/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0800</pubDate>
      
      <guid>http://devbins.github.io/post/nsd/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这些日子碰到这样一个需求，需要在局域网中发现我们创建的某个特定设备，并连上互相通信。本以为要去遍历整个局域网，后来查阅相关资料后发现 Android 为我们提供了网络服务发现（Network Service Discovery）简称 NSD，就是本文要讲的东西了。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
